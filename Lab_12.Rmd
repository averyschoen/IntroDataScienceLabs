---
title: "Lab 12"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(car)
library(dplyr)
library(GGally)
library(gghighlight)
library(ggplot2)
library(ggpubr)
library(gmodels)
library(gradethis)
library(learnr)
library(multcomp)
library(readr)
tutorial_options(exercise.checker = gradethis::grade_learnr)

library(Sleuth3)
ex0327

#model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

# square <- function(x){
#   xsquared <- x^2
# return(xsquared)}
# 
# discriminant <- function(a, b, C){
#   disc <- b^2 - 4*a*C
# return(disc)}
# 
# roots1 <- function(a, b, C){
#   x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
#   x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
# return(c(x1, x2))}
# 
# roots2 <- function(a, b, C){
#   x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
#   x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
# return(list(x1 = x1, x2 = x2))}
# 
# test <- roots2(5, 13, 3)
# 
# residualplots <- function(data = data, formula = formula){
#   model <- lm(data = data, formula = formula)
#   
#   residuals_df <- data.frame(cbind(model$fitted.values, model$residuals))
#   colnames(residuals_df) <- c("Fitted", "Residuals")
# 
#   resplot <- ggplot(data = model, aes(x = .fitted, y = .resid)) +
#     geom_point() + 
#     geom_hline(yintercept = 0, color = "red") +
#     xlab("Fitted") + 
#     ylab("Residuals")
#   
#   resdens <- ggplot(data = model, aes(x = .resid)) +
#     geom_histogram(aes(y=..density..), bins = 6) +
#     geom_density() + 
#     xlab("Residuals") +
#     ylab("Density")
#   
#   resqq <- ggplot(data = model, aes(sample = .resid)) +
#     stat_qq() +
#     stat_qq_line() +
#     xlab("Residuals")
#     ggtitle("Residuals Q-Q")
#   
#   resplots <- ggarrange(resplot, resdens, resqq, ncol = 3, nrow = 1)
#   returnlist <- list(residuals_df = residuals_df, resplots = resplots)
# return(returnlist)}
# 
# model1_residuals <- residualplots(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
# 
# threshold <- 2*model1$rank/dim(ex0327)[1]
# 
# ex0327$m1_highleverage <- as.factor(hatvalues(model1) > threshold)
# 
# diagnostics_df <- data.frame(cbind(1:dim(ex0327)[1], hatvalues(model1)))
# colnames(diagnostics_df) <- c("Index", "Leverage")
# 
# diagnostics_df$Studentized <- rstudent(model1)
# diagnostics_df$Cooks <- cooks.distance(model1)
# 
# diagnosticsplots <- function(data = data, formula = formula){
#   model <- lm(data = data, formula = formula)
#   
#   diagnostics_df <- data.frame(cbind(1:dim(data)[1], hatvalues(model1), 
#                                      rstudent(model1), cooks.distance(model1)))
#   colnames(diagnostics_df) <- c("Index", "Leverage", "Studentized", "Cook")
# 
#   threshold <- 2*model$rank/dim(data)[1]
#   
#   leverage <- ggplot(data = diagnostics_df, aes(x = Index, y = Leverage)) + 
#     geom_point() + 
#     geom_hline(yintercept = threshold, color = "red") + 
#     gghighlight(Leverage > threshold, label_key = Index)
#   
#   studres <- ggplot(data = diagnostics_df, aes(x = Index, y = Studentized)) + 
#     geom_point() + 
#     geom_hline(yintercept = -2, color = "red") + 
#     geom_hline(yintercept = 2, color = "red") +
#     gghighlight(abs(Studentized) > 2, label_key = Index)
#   
#   cooksd <- ggplot(data = diagnostics_df, aes(x = Index, y = Cook)) + 
#     geom_point() + 
#     geom_hline(yintercept = 1, color = "red") + 
#     gghighlight(Cook > 1, label_key = Index)
#   
#   plots <- ggarrange(leverage, studres, cooksd, ncol = 1, nrow = 3)
#   returnlist <- list(diagnostics_df = diagnostics_df, plots = plots)
#   return(returnlist)}
# 
# ex0327_34 <- ex0327[-34,]
# 
# model2 <- lm(ex0327_34, formula = logit(PollenRemoved) ~ DurationOfVisit*BeeType)
```

## Goals

Your goal is practice creating residual and diagnostic plots to investigate, but you will also learn how to write functions that can repeat complex sets of calculations for you! No more coding a million lines for every model to investigate. 

## Part 1: Loading Packages

Don't forget, packages must be loaded any time you want to use them in an R document. For this lab, we will continue using `car`, `GGally`, `ggplot2` and `ggpubr`, but we will also install a new package, `gghighlight`, that adds some extra functionality. Calls to load these packages are in the code chunk below. Go ahead and run this code chunk now.

```{r loadpackages, exercise = T}
library(car)
library(GGally)
library(gghighlight)
library(ggplot2)
library(ggpubr)
```

## Part 2: Reading in Data

We will be using data from Exercise 3.27 in the Statistical Sleuth. The dataset contains information on a study investigating reproductive strategies in plants, including the time a bee spends at a source of pollen and the proportions of pollen removed by the bee. Run the code below now to load the data set. No need to modify this code, but remember how to use this function to read in data in the future!

```{r ex0327, exercise = T}
library(Sleuth3)
data(ex0327)
```

## Part 3: Logical Operators and Booleans

Let's review some basic topics that will be useful for our other activities today.

### Logical Operators

At times it is useful to evaluate the truth of a statement in R--we will encounter one of these times in a minute! These statements usually involve logical operators, such as greater than (`>`) or less than (`>`). 

Write a line of code to confirm that seven is greater than five. 

```{r greaterthan, exercise = TRUE}

```

```{r greaterthan-solution, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}
7 > 5
```

```{r greaterthan-check, message = FALSE, warning = FALSE}
grade_code()
```

```{r 4_1, echo=FALSE, eval = F}
question("What is the output?",
  answer("TRUE", correct = TRUE),
  answer("FALSE"),
  answer("0"),
  answer("1"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

Write a line of code to confirm that eight is NOT greater than eleven. 

```{r lessthan, exercise = TRUE}

```

```{r lessthan-solution, message = FALSE, warning = FALSE, echo = FALSE}
8 > 11
```

```{r lessthan-check, message = FALSE, warning = FALSE}
grade_code()
```

```{r 4_2, echo=FALSE, eval = F}
question("What is the output?",
  answer("TRUE"),
  answer("FALSE", correct = TRUE),
  answer("0"),
  answer("1"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

Other logical operators include equal to `==`, less than or equal to `<=`, and greater than or equal to `>=`. Write a line of code to confirm that the square root of sixteen is 4. 

```{r equalto, exercise = TRUE}

```

```{r equalto-solution, message = FALSE, warning = FALSE, echo = FALSE}
sqrt(16) == 4
```

```{r equalto-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="residualplot1-hint">
**Hint:** Be careful to use TWO equal signs. 
</div>

Finally, we may be interested in values that are **not** equal to other values. 

See if you can find the R symbol representing "not equal to" by searching for it online. Write a line of code to confirm that the square root of 81 is not equal to 4. 

```{r notequalto, exercise = TRUE}

```

```{r notequalto-solution, message = FALSE, warning = FALSE, echo = FALSE}
sqrt(81) != 4
```

```{r notequalto-check, message = FALSE, warning = FALSE}
grade_code()
```

All of these logical operators (`>`, `<`, `==`, `>=`, `<=`, `!=`, among others!) produce the Boolean values `TRUE` and `FALSE` (or `T` and `F`). You have actually seen these values before, in some of the functions we have used. These values are not numbers, but they are sometimes treated as numeric. 

Write some code using the basic arithmetic operations and `TRUE` and `FALSE`. 

```{r truefalse, exercise = TRUE}

```

```{r 4_5, echo=FALSE}
question("Which number is `TRUE` is treated as, and which number is `FALSE` is treated as? This is a guess, so try as much as you need!",
  answer("`TRUE` is treated as a `100`, and `FALSE` is treated as a `-100`."),
  answer("`TRUE` is treated as a `1`, and `FALSE` is treated as a `0`.", correct = TRUE),
  answer("`TRUE` is treated as a `100`, and `FALSE` is treated as a `0`."),
  answer("`TRUE` is treated as a `1`, and `FALSE` is treated as a `-100`."),
  allow_retry = T,
  random_answer_order = TRUE
)
```

Logical operators in R are vectorized, just as the arithmetic operators. This means that you can store several values in a vector and test each of them against a logical operator.

The line of code beginning with `mult8` generates a vector of multiples of 8 between 8 and 96. Test all elements to see which are multiples of 3 using the line of code `mult8 %% 3 == 0`. 

```{r booleanvec, exercise = TRUE}
mult8 <- seq(from = 8, to = 96, by = 8)
```

```{r booleanvec-solution, message = FALSE, warning = FALSE, echo = FALSE}
mult8 <- seq(from = 8, to = 96, by = 8)
mult8 %% 3 == 0
```

```{r booleanvec-check, message = FALSE, warning = FALSE}
grade_code()
```

```{r 4_6, echo=FALSE}
question("How many responses (`TRUE` or `FALSE`) does R give you?",
  answer("There are 12 responses total (1 for each element)--eight are `TRUE` and four are `FALSE`."),
  answer("There are 12 responses total (1 for each element)--four are `TRUE` and eight are `FALSE`.", correct = TRUE),
  answer("There is 1 response (for the entire vector)--since not all of the elements are multiples of three, the answer is `FALSE`.", message = "There should be `12 responses!"),
  answer("There is 1 response (for the entire vector)--since at least one of the elements is a multiple of three, the answer is `TRUE`.", message = "There should be `12 responses!"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

We could count the number of `TRUE` values manually, but that can be time-consuming and error-prone. Instead, we can apply the `sum()` function to the code containing the logical operator `==` to count for us--remember, `TRUE` is treated as 1 and `FALSE` is treated as 0. Write a line of code to confirm that there are four multiples of 8 that are divisible by three between 8 and 96.

```{r prepare-boolean, message = FALSE}
mult8 <- seq(from = 8, to = 96, by = 8)
```

```{r booleansum, exercise = TRUE, exercise.setup = "prepare-boolean"}

```

```{r booleansum-solution, message = FALSE, warning = FALSE, echo = FALSE}
sum(mult8 %% 3 == 0)
```

```{r booleansum-check, message = FALSE, warning = FALSE}
grade_code()
```

We know that there are four multiples of 8 that are divisible by three--but which ones? The `which()` function will return the positions of the elements of `mult8` that are divisible by 3.

```{r which, exercise = TRUE, exercise.setup = "prepare-boolean"}
which()
```

```{r which-solution, message = FALSE, warning = FALSE, echo = FALSE}
which(mult8 %% 3 == 0)
```

```{r which-check, message = FALSE, warning = FALSE}
grade_code()
```

You can see that the $3^{rd}$, $6^{th}$, $9^{th}$, and $12^{th}$ elements are divisible by three (which makes sense, given the way that we constructed it). You can combine `which()` with a logical operator to get the positions of elements that satisfy that condition. Practice using `which()` below. 

Generate a sequence going from 0 to 100 by steps of 4 (named `mult4`). Find out which values are divisible by 7.

```{r which2, exercise = TRUE}
mult4 <- seq()
which()
```

```{r which2-solution, message = FALSE, warning = FALSE, echo = FALSE}
mult4 <- seq(from = 0, to = 100, by = 4)
which(mult4 %% 7 == 0)
```

```{r which2-check, message = FALSE, warning = FALSE}
grade_code()
```

Generate a sample of 30 values from the Standard Normal Distribution named `norm30` using `rnorm()`. Find out which are greater than 2. 

```{r which3, exercise = TRUE}
norm30 <- 
which()
```

```{r which3-solution, message = FALSE, warning = FALSE, echo = FALSE}
norm30 <- rnorm(30, mean = 0, sd = 1) 
which(norm30 > 2)
```

```{r which3-check, message = FALSE, warning = FALSE}
grade_code()
```

Find out which of the rows in `ex0327` have data for `"Worker"` bees. 

```{r which4, exercise = TRUE}
which()
```

```{r which4-solution, message = FALSE, warning = FALSE, echo = FALSE}
which(ex0327$BeeType == "Worker")
```

```{r which4-check, message = FALSE, warning = FALSE}
grade_code()
```

### Square Brackets

Every so often, you've seen me use the dollar sign (`$`) in R to pull out a column of a data frame. The dollar sign only works if you know the names of the columns. R can also extract rows, columns, or elements of a data frame using the square brackets (`[]`). This type of extraction is based on the positions. 

To extract a single element, you place the row index, a comma, and the column index inside the square brackets, which follow the name of the data frame (`dataframe[row, column]`). For example, you would code `ex0327[29, 3]` to extract the element in the $29^{th}$ row and the $3^{rd}$ column. 

Change the following line of code to extract the element in the $14^{th}$ row and the $2^{nd}$ column.

```{r sqbrackets, exercise = TRUE}
ex0327[29, 3]
```

```{r sqbrackets-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
ex0327[14, 2]
```

```{r sqbrackets-check, message = FALSE, warning = FALSE}
grade_code()
```

```{r 2_5}
question("What is the value in the $14^{th}$ row and the $2^{th}$ column?",
  answer("`35`", correct = TRUE),
  answer("`NULL`", message = "It looks like you have your indices flipped!"),
  answer("`Queen`", message = "Don't forget to change the values!"),
  answer("None of the above", message = "Keep trying!"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

You can also extract a whole row! Continue using the square brackets--however, leave the column index out. Extract the $44^{th}$ row from the `ex0327` data frame.  

```{r rindex, exercise = TRUE}

```

```{r rindex-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
ex0327[44,]
```

```{r rindex-check, message = FALSE, warning = FALSE}
grade_code()
```

To extract a column, you use the square brackets but leave the row index out. Extract the $1^{st}$ column from the `ex0327` data frame. 

```{r cindex, exercise = TRUE}

```

```{r cindex-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
ex0327[,1]
```

```{r cindex-check, message = FALSE, warning = FALSE}
grade_code()
```

Note that this is the same as `ex0321$PollenRemoved`--if we had known the name, we could have extracted it automatically! The difference between the dollar sign operator and the square brackets is like the difference between putting in "Mount Holyoke College" and "50 College Street, South Hadley, MA 01075" into your GPS. One requires you to know the name, and the other requires you to know the exact location.

## Part 4: Data Exploration

Create a plot of `PollenRemoved` variable against `DurationOfVisit`. For this plot, apply a special transform called the `logit()`--we have not covered it yet, but it will help make the data more linear. In addition to the scatterplot, color the points by `BeeType` and add lines to the model using `geom_smooth()`. 

```{r scatterplot, exercise = TRUE}
ggplot(data = ex0327, aes(x = DurationOfVisit, y = logit(PollenRemoved))) +
```

```{r scatterplot-solution}
ggplot(data = ex0327, aes(x = DurationOfVisit, y = logit(PollenRemoved), color = BeeType)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

```{r scatterplot-check, message = FALSE, warning = FALSE}
grade_code()
```

Does it look reasonable to use linear models to describe the data?

### Model Fitting

Fit a linear model, named `model1`, predicting the logit of `PollenRemoved` from the interaction `DurationOfVisit` and `BeeType`. 

```{r model1, exercise = TRUE}

```

```{r model1-solution}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
```

```{r model1-check, message = FALSE, warning = FALSE}
grade_code()
```

Write the equation describing this linear model. 

### A Function for Residual Plots

Using this model, create a scatterplot of the residuals. 

```{r prepare-model, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
```

```{r resids1, exercise = TRUE, exercise.setup = "prepare-model"}

```

```{r resids1-solution}
ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()
```

```{r resids1-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, create a QQ plot of the residuals to see if they are normal. 

```{r resids2, exercise = TRUE, exercise.setup = "prepare-model"}

```

```{r resids2-solution}
ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")
```

```{r resids2-check, message = FALSE, warning = FALSE}
grade_code()
```

The plot for each code appears below--save them as `residualplot` and `qqplot`. Then, apply the `ggarrange()` function to put both plots on the same row. 

```{r resids3, exercise = TRUE, exercise.setup = "prepare-model"}
ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")
```

```{r resids3-solution}
residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)
```

```{r resids3-check, message = FALSE, warning = FALSE}
grade_code()
```

Does it seem like this linear model is appropriate for the data, based on these plots?

## Part 5: Writing Functions

When we have to repeat a set of calculations multiple times, like when making residual plots, it can be helpful to write a function. You have control about the arguments, calculations, and the output of the functions you write. The code below mimics the general structure of the functions. 

```{r functionexample, exercise = TRUE}
my.function <- function(argument1, argument2, ...){
  
  calculations, calculations, calculations
  
  return(output)}
```

* First of all, you select the name for your function. The name should be simple, but informative enough to help you remember what the function does. I have chosen `my.function`.
* Next, you store the actual calculations of the function into the name you have chosen using the right arrow, `<-`. 
* The `function` is the command assigned to declare a function. You cannot create your own functions without using this command.
     + Inside the function, you can declare the arguments you would like to use. You can use as many as you want. You should name the arguments--again, simple names but relatively informative.
* After the function, you use the curly braces, `{}`, around the calculations that you want to repeat. These calculations can be as complex as you like!
* The `return()` is the command assigned to declare the outputs of your function. **If you don't include it, your function will not produce any outputs--it will perform the calculations, but you will not be able to recover them**

### Functions with One Argument

Below, I have written the outline of a function for squaring a variable (which we already have a way to do, but this is helpful for learning). What calculations belong inside the curly braces? Since we used the argument `x`, the calculations should be written in terms of `x`. 

```{r function1, exercise = TRUE}
square <- function(x){
  xsquared <-
return(xsquared)}
```

```{r function1-solution}
square <- function(x){
  xsquared <- x^2
return(xsquared)}
```

```{r function1-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, using your function, find the square of `9`--hopefully, it is what you expect! 

```{r prepare-functiona, message = FALSE}
square <- function(x){
  xsquared <- x^2
return(xsquared)}
```

```{r function2, exercise = TRUE, exercise.setup = "prepare-functiona"}

```

```{r function2-solution}
square(9)
```

```{r function2-check, message = FALSE, warning = FALSE}
grade_code()
```

### Functions with Multiple Arguments

You can also write a function with multiple arguments by typing them inside the parentheses and separating them with commas. 

Below, I have written the outline of a function for solving for the discriminant of a quadratic equation $ax^2 + bx + c$. The discriminant is given by 

$$b^2 - 4ac.$$
Fill in the rest of the function with arguments `a`, `b`, and `C` (use a capital `C` because the lowercase `c` already has a job in R--the function `c()` creates vectors, and it is bad practice to overwrite existing objects).

```{r function3, exercise = TRUE}
discriminant <- function(...){
  disc <- 
}
```

```{r function3-solution}
discriminant <- function(a, b, C){
  disc <- b^2 - 4*a*C
return(disc)}
```

```{r function3-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="function3-hint">
**Hint:** Don't forget to return the result!   
</div>

Now, apply your function to find the discriminant of the quadratic equation $3x^2 - 8x + 5$.

```{r prepare-functionb, message = FALSE}
discriminant <- function(a, b, C){
  disc <- b^2 - 4*a*C
return(disc)}
```

```{r function4, exercise = TRUE, exercise.setup = "prepare-functionb"}

```

```{r function4-solution}
discriminant(3, -8, 5)
```

```{r function4-check, message = FALSE, warning = FALSE}
grade_code()
```

### Functions with Multiple Results

There are also times where we want to create functions that produce multiple results. Unfortunately, `return()` only returns a single object. However, we can "trick" R into returning multiple results by combining them into one object. 

For example, a quadratic equation  $ax^2 + bx + c$ has two roots. If we plugged in the coefficients into a function, we would want to see both of them--they are defined by 

$$x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$$

Below, I have written the outline of a function that returns both of the $x$ values in a vector. Fill in the rest of the function and solve for the roots of $3x^2 - 8x + 5$. 

```{r function5, exercise = TRUE, exercise.setup = "prepare-functionb"}
roots1 <- function(a, b, C){
  x1 <-  
  x2 <- 
return(c(x1, x2))}
```

```{r function5-solution}
roots1 <- function(a, b, C){
  x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
  x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
return(c(x1, x2))}
roots1(3, -8, 5)
```

```{r function5-check, message = FALSE, warning = FALSE}
grade_code()
```

Returning a single vector is a reasonable solution, but all you get out is the vector! You may not know or remember what the element of the vector represents--it just appears as a number--or, you may not remember where you stored a result.

To solve this problem, we can return a list instead of a vector. A `list` in R can save multiple named objects that may be different types (numbers, character strings, vectors, matrices, etc.).

Below, I have written the outline of a function that returns both of the solutions for a quadratic equation in a list. Fill in the rest of the function. 

```{r function6, exercise = TRUE, exercise.setup = "prepare-functionb"}
  x1 <- 
  x2 <- 
return(list(x1 = x1, x2 = x2))
```

```{r function6-solution}
roots2 <- function(a, b, C){
  x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
  x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
return(list(x1 = x1, x2 = x2))}
```

```{r function6-check, message = FALSE, warning = FALSE}
grade_code()
```

Find the roots of the equation $5x^2 + 13x + 3$ using your second function, and save them in an object named `test`. 

```{r prepare-functionc, message = FALSE}
discriminant <- function(a, b, C){
  disc <- b^2 - 4*a*C
return(disc)}

roots2 <- function(a, b, C){
  x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
  x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
return(list(x1 = x1, x2 = x2))}
```

```{r function7, exercise = TRUE, exercise.setup = "prepare-functionc"}

```

```{r function7-solution}
test <- roots2(5, 13, 3)
```

```{r function7-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, extract `x1` from `test` using the dollar sign, `$`. 

```{r prepare-functiond, message = FALSE}
discriminant <- function(a, b, C){
  disc <- b^2 - 4*a*C
return(disc)}

roots2 <- function(a, b, C){
  x1 <- (-b + sqrt(discriminant(a, b, C)))/(2*a) 
  x2 <- (-b - sqrt(discriminant(a, b, C)))/(2*a) 
return(list(x1 = x1, x2 = x2))}

test <- roots2(5, 13, 3)
```

```{r function8, exercise = TRUE, exercise.setup = "prepare-functiond"}

```

```{r function8-solution}
test$x1
```

```{r function8-check, message = FALSE, warning = FALSE}
grade_code()
```

Finally, extract `x2` from `test` using the dollar sign, `$`. 

```{r function9, exercise = TRUE, exercise.setup = "prepare-functiond"}

```

```{r function9-solution}
test$x2
```

```{r function9-check, message = FALSE, warning = FALSE}
grade_code()
```

### A Function for Residual Plots

To recap, we created these plots by 

1. Fitting the model,
2. Creating and saving each plot, and
3. Arranging the two plots. 

This code appears in the chunk below. 

```{r resids4, exercise = TRUE, exercise.setup = "prepare-model"}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)
```

If we place this code inside a function, we never have to redo it again! Instead, we can just apply the function. Try copying and pasting it all inside the brackets defining the function `residual_plots()`. 

```{r resids5, exercise = TRUE, exercise.setup = "prepare-model"}
residual_plots <- function(argument1, argument2, ...){
  
  calculations, calculations, calculations
  
  return(output)}
```

```{r resids5-solution}
residual_plots <- function(argument1, argument2, ...){
  
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids5-check, message = FALSE, warning = FALSE}
grade_code()
```

You may notice that we haven't specified the arguments to the function! The way we have written the code, the only things we absolutely need is the dataset used and the formula. Add those arguments to the function. 

```{r resids6, exercise = TRUE, exercise.setup = "prepare-model"}
residual_plots <- function(argument1, argument2){
  
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids6-solution}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids6-check, message = FALSE, warning = FALSE}
grade_code()
```

Notice now that the arguments in the function don't actually show up anywhere in the code! We need to adapt our model statement inside `lm()` to use these arguments. 

```{r resids7, exercise = TRUE, exercise.setup = "prepare-model"}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids7-solution}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = dataset, formula = formula)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids7-check, message = FALSE, warning = FALSE}
grade_code()
```

Now realize that we haven't actually returned anything--what's more, we don't have anything nice to return (at least, not the nice plot with all three diagnostics). Save the code in `ggarrange()`, and add a return statement. 

```{r resids8, exercise = TRUE, exercise.setup = "prepare-model"}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = dataset, formula = formula)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids8-solution}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = dataset, formula = formula)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

output <- ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids8-check, message = FALSE, warning = FALSE}
grade_code()
```

Now you have a working function!! Note that if you want to use this function in your own work, you are welcome to do so. However, it doesn't magically appear--you will have to copy and paste this code into your RMarkdown documents before you can use it. 

You can also adapt it to be a nicer function or to do different things if you so choose. Consider adding a red line through 0, nicer titles, etc.

Now, apply this function to the current scenario, to make sure it works~

```{r prepare-residplots, message = FALSE}
residual_plots <- function(dataset = dataset, formula = formula){
  
model1 <- lm(data = dataset, formula = formula)

residualplot <- ggplot(data = model1, aes(x = .fitted, y = .resid)) +
  geom_point()

qqplot <- ggplot(data = model1, aes(sample = .resid)) +
   stat_qq() +
   stat_qq_line() +
   ggtitle("Residuals Q-Q")

output <- ggarrange(residualplot, qqplot, nrow = 1, ncol = 2)  
  return(output)}
```

```{r resids9, exercise = TRUE, exercise.setup = "prepare-residplots"}

```

```{r resids9-solution}
residual_plots(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
```

```{r resids9-check, message = FALSE, warning = FALSE}
grade_code()
```

## Part 6: Case-Influence Statistics

### Leverage

To see if there are any influential points, calculate the leverage values for `model1`.

```{r leverage1, exercise = TRUE, exercise.setup = "prepare-model"}

```

```{r leverage1-solution}
hatvalues(model1)
```

```{r leverage1-check, message = FALSE, warning = FALSE}
grade_code()
```

Remember that the threshold for high and low leverage values depends on the number of data points and the number of coefficients in the model.

It turns out that we can automatically extract the number of points using the `dim()` command. However, `dim()` returns a vector where the first value is the number of rows (corresponding to points). Using the square brackets, can you extract the first value?

```{r threshold1, exercise = TRUE}
dim(ex0327)
```

```{r threshold1-solution}
dim(ex0327)[1]
```

```{r threshold1-check, message = FALSE, warning = FALSE}
grade_code()
```

You can also directly extract the number of coefficients from `model1` (and other models you might fit). This value is saved as `rank`. 

```{r threshold2, exercise = TRUE, exercise.setup = "prepare-model"}
model1$rank
```

```{r threshold3, echo=FALSE}
question("The number of coefficients in the model is...",
  answer("4", correct = TRUE),
  answer("1"),
  answer("2"),
  answer("3"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

Using these two values, calculate the threshold for high leverage values, $2\frac{p}{n}$.

```{r leverage2, exercise = TRUE, exercise.setup = "prepare-model"}

```

```{r leverage2-solution}
threshold <- 2*model1$rank/dim(ex0327)[1]
threshold
```

```{r leverage2-check, message = FALSE, warning = FALSE}
grade_code()
```

Now's the time to use logical operators, like `>` and `<`! Other operators include less than or equal to (`<=`), greater than or equal to (`>=`), equal to (`==`), and not equal to (`!=`), among others. They all work in very similar ways to `<` and `>`--to learn more logical operators, check out this [list](https://www.statmethods.net/management/operators.html).

Again, we will focus on are `<` and `>`--we will use them to identify which points have high leverage values, studentized residuals, etc. Using the `which()` function, the calculated threshold, and a logical operator, write two lines of code to determine how many high leverage points there are and which rows they are in. 

```{r prepare-model2, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]
```

```{r leverage3, exercise = TRUE, exercise.setup = "prepare-model2"}

```

```{r leverage3-solution}
sum(hatvalues(model1) > threshold) 
which(hatvalues(model1) > threshold)
```

```{r leverage3-check, message = FALSE, warning = FALSE}
grade_code()
```

You might be interested in showing high leverage points (or points with high valued studentized residuals or Cook's distance) on a scatterplot of the original data. This requires some extra work.

`ggplot()` requires that your data is stored as a data frame. We can create this data frame using `data.frame()`. See the code below--it creates a data frame named `diagnostics`, containing `index` (the row numbers) and `m_leverage` (the leverage values from `model1`).

```{r leverage4, exercise = TRUE, exercise.setup = "prepare-model2"}
diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1))
```

Now that you have created the dataframe, you can easily make a scatterplot with `index` on the $x$-axis and `m_leverage` on the $y$-axis.

```{r prepare-model3, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1))
```

```{r leverage5, exercise = TRUE, exercise.setup = "prepare-model3"}

```

```{r leverage5-solution}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point()
```

```{r leverage5-check, message = FALSE, warning = FALSE}
grade_code()
```

We can add a red line to represent the threshold with `geom_hline()`. You've done this before, but remember that `geom_hline()` accepts a `yintercept` argument to show exactly where the line should go and a `color` argument to make it red. 

```{r leverage6, exercise = TRUE, exercise.setup = "prepare-model3"}

```

```{r leverage6-solution}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  geom_hline(yintercept = threshold, color = "red")
```

```{r leverage6-check, message = FALSE, warning = FALSE}
grade_code()
```

To add one last feature to this graph, we can use the package `gghighlight`. As the name suggests, we can highlight certain points according to some condition defined with a logical operator (called a predicate). 

Use the code from your last graph, and add the geom `gghighlight()` to the plot. Inside the parentheses, write a phrase that specifies what you are interested in--we want to see which values of `m_leverage` are greater than the stored `threshold` value.

```{r leverage7, exercise = TRUE, exercise.setup = "prepare-model3"}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight() +
  geom_hline(yintercept = threshold, color = "red") 
```

```{r leverage7-solution}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold) + 
  geom_hline(yintercept = threshold, color = "red") 
```

```{r leverage7-check, message = FALSE, warning = FALSE}
grade_code()
```

In addition to the colors changing, we can label the points. The argument `label_key` dictates what the points are labeled with--in this case, we want to label each point with the `index` so we can find exactly what rows are problematic. Add the argument to see if you can label the points. 
  
```{r leverage8, exercise = TRUE, exercise.setup = "prepare-model3"}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = ) +
  geom_hline(yintercept = threshold, color = "red") 
```

```{r leverage8-solution}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) +
  geom_hline(yintercept = threshold, color = "red")
```

```{r leverage8-check, message = FALSE, warning = FALSE}
grade_code()
```

As a final touch, change the labels on the $x$ and $y$ axes to read `Index` and `Leverage`.

```{r leverage9, exercise = TRUE, exercise.setup = "prepare-model3"}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) +
  geom_hline(yintercept = threshold, color = "red")
```

```{r leverage9-solution}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) +
  geom_hline(yintercept = threshold, color = "red") + 
  xlab("Index") + 
  ylab("Leverage")
```

```{r leverage9-check, message = FALSE, warning = FALSE}
grade_code()
```

### Studentized Residuals

Now, let's take a look at the studentized residuals. Compute the values for `model1`. 

```{r studentized1, exercise = TRUE, exercise.setup = "prepare-model3"}

```

```{r studentized1-solution}
rstudent(model1)
```

```{r studentized1-check, message = FALSE, warning = FALSE}
grade_code()
```

Using the `sum()` and `which()` functions, the calculated threshold, and a logical operator, write two lines of code to determine how many points with large studentized residuals there are and which rows they are in. 

```{r studentized2, exercise = TRUE, exercise.setup = "prepare-model3"}

```

```{r studentized2-solution}
sum(abs(rstudent(model1)) > 2)
which(abs(rstudent(model1)) > 2)
```

```{r studentized2-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="studentized2-hint">
**Hint:** You may need to use the `abs()` function.   
</div>

Now, let's plot the studentized residuals. Instead of creating a brand new dataframe, add the residuals to the existing `diagnostics` dataframe in a new column labeled `m_studentized`.

```{r studentized3, exercise = TRUE, exercise.setup = "prepare-model3"}

```

```{r studentized3-solution}
diagnostics <- diagnostics %>%
  mutate(m_studentized = rstudent(model1))
```

```{r studentized3-check, message = FALSE, warning = FALSE}
grade_code()
```

Using the dataframe and `ggplot()`, create a scatterplot of the index on the $x$-axis and the studentized residuals on the $y$-axis.

```{r prepare-model4, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1))

diagnostics <- diagnostics %>%
  mutate(m_studentized = rstudent(model1))
```

```{r studentized4, exercise = TRUE, exercise.setup = "prepare-model4"}

```

```{r studentized4-solution}
ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point()
```

```{r studentized4-check, message = FALSE, warning = FALSE}
grade_code()
```

Using `geom_hline()`, add two new red lines at -2 and 2 so we can identify the points with high studentized residuals.

```{r studentized5, exercise = TRUE, exercise.setup = "prepare-model4"}

```

```{r studentized5-solution}
ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  geom_hline(yintercept = 2, color = "red") + 
  geom_hline(yintercept = -2, color = "red") 
```

```{r studentized5-check, message = FALSE, warning = FALSE}
grade_code()
```

Finally, use `gghighlight()` to label the points with high residuals.

```{r studentized6, exercise = TRUE, exercise.setup = "prepare-model4"}

```

```{r studentized6-solution}
ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  gghighlight(abs(m_studentized) > 2, label_key = index) +
  geom_hline(yintercept = -2, color = "red") + 
  geom_hline(yintercept = 2, color = "red")
```

```{r studentized6-check, message = FALSE, warning = FALSE}
grade_code()
```

Do the groups share any overlap?

### Cook's Distance

Finally, let's calculate the Cook's distance. Include code that will calculate how many points have high Cook's distance and which ones they are. 

```{r cooks1, exercise = TRUE, exercise.setup = "prepare-model4"}

```

```{r cooks1-solution}
cooks.distance(model1)
sum(cooks.distance(model1) > 1)
which(cooks.distance(model1) > 1)
```

```{r cooks1-check, message = FALSE, warning = FALSE}
grade_code()
```

Add a column with the Cook's distance named `m_cooks` to the `diagnostics` dataframe, and plot the index on the $x$-axis and the Cook's distance on the $y$-axis. 

```{r cooks2, exercise = TRUE, exercise.setup = "prepare-model4"}

```

```{r cooks2-solution}
diagnostics <- diagnostics %>%
  mutate(m_cooks = cooks.distance(model1))

ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
  geom_point() + 
  gghighlight(m_cooks > 1, label_key = index) +
  geom_hline(yintercept = 1, color = "red")
```

```{r cooks2-check, message = FALSE, warning = FALSE}
grade_code()
```

We know that statisticians typically like to consider all of these plots at once. You've seen the `ggarrange()` formula -- in the chunk below, save the plots you've just created as `leverage_plot`, `rstudentized_plot`, and `cooks_plot` (while you're at it, change the axis titles for all your plots). 

```{r prepare-model5, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1))

diagnostics <- diagnostics %>%
  mutate(m_studentized = rstudent(model1))

diagnostics <- diagnostics %>%
  mutate(m_cooks = cooks.distance(model1))
```

```{r diagnostics1, exercise = TRUE, exercise.setup = "prepare-model5"}
ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) + 
  geom_hline(yintercept = threshold, color = "red") + 
  xlab("Index") + 
  ylab("Leverage")

ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  gghighlight(abs(m_studentized) > 2, label_key = index) +
  geom_hline(yintercept = -2, color = "red") + 
  geom_hline(yintercept = 2, color = "red")

ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
  geom_point() + 
  gghighlight(m_cooks > 1, label_key = index) +
  geom_hline(yintercept = 1, color = "red") 
```

```{r diagnostics1-solution}
leverage_plot <- ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) + 
  geom_hline(yintercept = threshold, color = "red") + 
  xlab("Index") + 
  ylab("Leverage")

rstudentized_plot <- ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  gghighlight(abs(m_studentized) > 2, label_key = index) + 
  geom_hline(yintercept = -2, color = "red") + 
  geom_hline(yintercept = 2, color = "red") +
  xlab("Index") + 
  ylab("Studentized")

cooks_plot <- ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
  geom_point() + 
  gghighlight(m_cooks > 1, label_key = index) + 
  geom_hline(yintercept = 1, color = "red") + 
  xlab("Index") + 
  ylab("Cook's D")
```

```{r diagnostics1-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, using `ggarrange()`, plot the three plots all together (3 rows, 1 column).

```{r prepare-model6, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1))

diagnostics <- diagnostics %>%
  mutate(m_studentized = rstudent(model1))

diagnostics <- diagnostics %>%
  mutate(m_cooks = cooks.distance(model1))

leverage_plot <- ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) + 
  geom_hline(yintercept = threshold, color = "red") + 
  xlab("Index") + 
  ylab("Leverage")

rstudentized_plot <- ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  gghighlight(abs(m_studentized) > 2, label_key = index) + 
  geom_hline(yintercept = -2, color = "red") + 
  geom_hline(yintercept = 2, color = "red") +
  xlab("Index") + 
  ylab("Studentized")

cooks_plot <- ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
  geom_point() + 
  gghighlight(m_cooks > 1, label_key = index) + 
  geom_hline(yintercept = 1, color = "red") + 
  xlab("Index") + 
  ylab("Cook's D")
```

```{r diagnostics2, exercise = TRUE, exercise.setup = "prepare-model6"}

```

```{r diagnostics2-solution}
ggarrange(leverage_plot, rstudentized_plot, cooks_plot, nrow = 3, ncol = 1)
```

```{r diagnostics2-check, message = FALSE, warning = FALSE}
grade_code()
```

We can make this into a function as well! Using the same process, create a function named `diagnostics_plots()`.  To recap, we created *these* plots by 

1. Fitting the model,
2. Creating a data frame,
3. Creating and saving each plot, and
4. Arranging the two plots. 

This code appears in the chunk below (although I have adapted the code for the data frame creation slightly). 

```{r diagnostics3, exercise = TRUE, exercise.setup = "prepare-model6"}
my.function <- function(argument1, argument2, ...){

model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnostics <- data.frame(index = 1:dim(ex0327)[1], 
                        m_leverage = hatvalues(model1),
                        m_studentized = rstudent(model1),
                        m_cooks = cooks.distance(model1))

leverage_plot <- ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
  geom_point() + 
  gghighlight(m_leverage > threshold, label_key = index) + 
  geom_hline(yintercept = threshold, color = "red") + 
  xlab("Index") + 
  ylab("Leverage")

rstudentized_plot <- ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
  geom_point() + 
  gghighlight(abs(m_studentized) > 2, label_key = index) + 
  geom_hline(yintercept = -2, color = "red") + 
  geom_hline(yintercept = 2, color = "red") +
  xlab("Index") + 
  ylab("Studentized")

cooks_plot <- ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
  geom_point() + 
  gghighlight(m_cooks > 1, label_key = index) + 
  geom_hline(yintercept = 1, color = "red") + 
  xlab("Index") + 
  ylab("Cook's D")

  ggarrange(leverage_plot, rstudentized_plot, cooks_plot, nrow = 3, ncol = 1)

  return(output)}
```

Now apply the function to your dataset, just to make sure it works!

```{r prepare-model7, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnosticsplots <- function(dataset = dataset, formula = formula){

  model1 <- lm(data = dataset, formula = formula )
  threshold <- 2*model1$rank/dim(dataset)[1]

  diagnostics <- data.frame(index = 1:dim(dataset)[1], 
                          m_leverage = hatvalues(model1),
                          m_studentized = rstudent(model1),
                          m_cooks = cooks.distance(model1))

  leverage_plot <- ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
    geom_point() + 
    gghighlight(m_leverage > threshold, label_key = index) + 
    geom_hline(yintercept = threshold, color = "red") + 
    xlab("Index") + 
    ylab("Leverage")

  rstudentized_plot <- ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
    geom_point() + 
    gghighlight(abs(m_studentized) > 2, label_key = index) + 
    geom_hline(yintercept = -2, color = "red") + 
    geom_hline(yintercept = 2, color = "red") +
    xlab("Index") + 
    ylab("Studentized")

  cooks_plot <- ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
    geom_point() + 
    gghighlight(m_cooks > 1, label_key = index) + 
    geom_hline(yintercept = 1, color = "red") + 
    xlab("Index") + 
    ylab("Cook's D")

  output <- ggarrange(leverage_plot, rstudentized_plot, cooks_plot, nrow = 3, ncol = 1)

  return(output)}
```

```{r diagnostics4, exercise = TRUE, exercise.setup = "prepare-model7"}

```

```{r diagnostics4-solution}
diagnosticsplots(data = ex0327, formula = logit(PollenRemoved) ~ DurationOfVisit*BeeType)
```

```{r diagnostics4-check, message = FALSE, warning = FALSE}
grade_code()
```

## Part 7: Deleting Cases

It is clear from the three plots that case 34 is an influential point. Before we remove from the dataset, view the summary of `model1`. Are any of the coefficients significant?

```{r summary1, exercise = TRUE, exercise.setup = "prepare-model7"}

```

```{r summary1-solution}
summary(model1)
```

```{r summary1-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, create a new dataframe named `ex0327_34` by using the square brackets to delete the $34^{th}$ row. 

```{r delete, exercise = TRUE, exercise.setup = "prepare-model7"}

```

```{r delete-solution}
ex0327_34 <- ex0327[-34,]
```

```{r delete-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="delete-hint">
**Hint:** You can delete a row by using a negative sign in front of the row you want to eliminate.   
</div>

Refit the model without the $34^{th}$ observation (named `model2`) and view the summary.

```{r prepare-model8, message = FALSE}
model1 <- lm(data = ex0327, logit(PollenRemoved) ~ DurationOfVisit*BeeType)
threshold <- 2*model1$rank/dim(ex0327)[1]

diagnosticsplots <- function(dataset = dataset, formula = formula){

  model1 <- lm(data = dataset, formula = formula )
  threshold <- 2*model1$rank/dim(dataset)[1]

  diagnostics <- data.frame(index = 1:dim(dataset)[1], 
                          m_leverage = hatvalues(model1),
                          m_studentized = rstudent(model1),
                          m_cooks = cooks.distance(model1))

  leverage_plot <- ggplot(data = diagnostics, aes(x = index, y = m_leverage)) + 
    geom_point() + 
    gghighlight(m_leverage > threshold, label_key = index) + 
    geom_hline(yintercept = threshold, color = "red") + 
    xlab("Index") + 
    ylab("Leverage")

  rstudentized_plot <- ggplot(data = diagnostics, aes(x = index, y = m_studentized)) + 
    geom_point() + 
    gghighlight(abs(m_studentized) > 2, label_key = index) + 
    geom_hline(yintercept = -2, color = "red") + 
    geom_hline(yintercept = 2, color = "red") +
    xlab("Index") + 
    ylab("Studentized")

  cooks_plot <- ggplot(data = diagnostics, aes(x = index, y = m_cooks)) + 
    geom_point() + 
    gghighlight(m_cooks > 1, label_key = index) + 
    geom_hline(yintercept = 1, color = "red") + 
    xlab("Index") + 
    ylab("Cook's D")

  output <- ggarrange(leverage_plot, rstudentized_plot, cooks_plot, nrow = 3, ncol = 1)

  return(output)}

ex0327_34 <- ex0327[-34,]
```

```{r summary2, exercise = TRUE, exercise.setup = "prepare-model8"}

```

```{r summary2-solution}
model2 <- lm(ex0327_34, formula = logit(PollenRemoved) ~ DurationOfVisit*BeeType)
summary(model2)
```

```{r summary2-check, message = FALSE, warning = FALSE}
grade_code()
```

Do the results of your analysis change? What is the best course of action?


