---
title: "Lab 4"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(dplyr)
library(ggplot2)
library(gradethis)
library(learnr)
library(multcomp)
library(RColorBrewer)
library(readr)
tutorial_options(exercise.checker = gradethis::grade_learnr)

vec1 <- c(1, 2, 3, 4)
vec2 <- c(8, 7, 6, 5)


socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv")

livewith.factor <- as.factor(socsupport$livewith)
socsupport$livewith.factor <- as.factor(socsupport$livewith)

socsupport$alone <- 0
socsupport$alone[socsupport$livewith.factor == "alone"] <- "alone"
socsupport$alone[socsupport$livewith.factor != "alone"] <- "else"
socsupport$alone <- as.factor(socsupport$alone)

mfull <- lm(data = socsupport, formula = emotionalsat ~ livewith.factor)
```

## Goals

Your goal is practice more $F$-tests and multiple comparisons, but you will also learn some strategies for working with different types of data in R.

## Part 1: Loading Packages

Don't forget, packages must be loaded any time you want to use them in an R document. For this lab, we will continue using `dplyr` and `ggplot2` as well as a new package, `kableExtra`.  Calls to load these packages are in the code chunk below. Go ahead and run this code chunk now.

```{r loadpackages, exercise = T}
library(dplyr)
library(ggplot2)
library(kableExtra)
```

## Part 2: Reading in Data

The following R code reads in the data set from a survey on social and emotional support and stores it in a dataframe called `socsupport`. You will be working mostly with the variables `livewith` and `emotionalsat`, which describe the respondent's living arrangements and their satisfaction with their level of emotional support (there are many variables in this dataset--read more at the [dataset documentation](https://vincentarelbundock.github.io/Rdatasets/doc/DAAG/socsupport.html)).  Run the code below now to read in the data set.  No need to modify this code, but remember how to use this function to read in data in the future!

```{r socsupport, exercise = T}
socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv")
```

## Part 3: ANOVA in R

### Factors

Last lab, we learned about numeric values (`<dbl>`, `<int>`) and character strings (`<chr>`) in R. There is a third commonly used type called a "factor" (`<fct>`), which is how R stores categorical variables (like the different group memberships used for ANOVA). Factors can look like either numeric values or character strings, but it is important to make sure that different variables are *stored* as factors for analysis methods like ANOVA to work properly.

The `is.factor()` function will check to see if a variable is stored as a factor. In order to run an ANOVA on our dataset, we need the variable describing living arrangements, `livewith`, in the `socsupport` dataframe to be a factor. Check to see if `livewith` is a factor in the chunk below. 

```{r factor1, exercise = TRUE}
is.factor()
```

```{r factor1-solution}
is.factor(socsupport$livewith)
```

```{r factor1-check, message = FALSE, warning = FALSE}
grade_code()
```

You should see that this variable is not a factor. Let's learn how to change it! We can force R to turn it into a factor using `as.factor()`. Run the code below to see an example.

```{r factor2, exercise = TRUE}
as.factor(socsupport$livewith)
```

Note that running this code alone outputs a "factorized" version of the `livewith` variable, but this new factor has not been saved so we can't work with it later! Using `mutate()` from the `dplyr` package, create a new column with the factorized version of `livewith`  called `livewith.factor`.

```{r factor3, exercise = TRUE}
socsupport <-socsupport %>%
  mutate()
```

```{r factor3-solution}
socsupport <-socsupport %>%
  mutate(livewith.factor = as.factor(livewith))
```

```{r factor3-check, message = FALSE, warning = FALSE}
grade_code()
```

All the functions you have learned for converting character strings into factors are useful, but in the future, you might be able to bypass the problem directly in `read.csv()`! This is the approach we will take from now on, illustrated in the following code:

```{r factor4, exercise = TRUE}
socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv", stringsAsFactors = TRUE)
is.factor(socsupport$livewith)
```

Now, all of the variables are factors! So you don't have to create new columns--you can use the original column names directly. 

### Exploratory Data Analysis with Factors

Just as `unique()` can be used with character strings, it can be used with factors as well. Another useful function when working with factors is the `levels()` function--remember that the levels of a categorical variable are the possible values the variable can take. Using `levels()`, confirm that the possible values of `socsupport$livewith` are `"alone"`, `"friends"`, `"other"`, `"parents"`, `"partner"`, and  `"residences"`.

```{r prepare-part2, message = FALSE}
socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv", stringsAsFactors = TRUE)
mfull <- lm(data = socsupport, formula = emotionalsat ~ livewith)
```

```{r factor5, exercise = TRUE, exercise.setup = "prepare-part2"}
levels()
```

```{r factor5-solution}
levels(socsupport$livewith)
```

```{r factor5-check, message = FALSE, warning = FALSE}
grade_code()
```

Factors in R always have a reference level. Typically, R treats the factor that comes first alphabetically or numerically as the reference. To check the reference, use `levels()`--the reference level is always listed first.

Let's say for some reason, you want to change the reference level. Currently, the reference level is `"alone"`, but we might be interested in setting the baseline as `"parents"` (since most people start off their lives living with parents). This can be accomplished using the `relevel()` function. First, you supply the variable you would like to "relevel". Next, you supply the `ref` by using the exact character string of the level you wish to use as the reference.

Change the reference level of `livewith` to `"parents"`. Check by looking at the levels of `livewith`.

```{r factor6, exercise = TRUE, exercise.setup = "prepare-part2"}
socsupport <-socsupport %>%
  mutate(livewith = relevel(livewith, ref = ))
levels()
```

```{r factor6-solution}
socsupport <-socsupport %>%
  mutate(livewith = relevel(livewith, ref = "parents"))
levels(socsupport$livewith)
```

```{r factor6-check, message = FALSE, warning = FALSE}
grade_code()
```

If you want to change the entire order of the factor, use code similar to the following:

```{r factor7, exercise = TRUE, exercise.setup = "prepare-part2"}
socsupport <-socsupport %>%
  mutate(livewith = factor(livewith, levels = c("parents", "residences", "friends", "alone", "partner", "other")))
levels(socsupport$livewith)
```

### Practicing ANOVA

Now that we have explored the data and converted everything to the appropriate storage type, we can (finally!!) investigate the differences in the mean emotional support satisfaction among different groups. Let's start by considering the mean emotional support satisfaction among people living alone, with friends, parents, or partners, in residences, and "other".

$$H_0: \mu_{alone} = \mu_{friends} = \mu_{other} = \mu_{parents} = \mu_{partners} = \mu_{residences} \text{ vs. }$$
$$H_A: \text{At least one of the means of emotional support satisfaction is different.}$$

Is there evidence at a 5% significance level that any of the group means are different? 

#### Data Exploration

First, we should check the assumptions using some type of plot. You've already experimented with histograms and `facet_grid()` on earlier homework assignments--recreate a plot that shows one histogram of `emotionalsat` for every level of `livewith` in the chunk below. Remember that you need a formula in your `facet_grid()` command!

```{r formula1, echo = F}
question("Which is the correct formula for splitting the histograms for the different levels of `emotionalsat` into rows?",
  answer("`.~livewith`", message = "This will put them into different columns!"),
  answer("`livewith~.`", correct = TRUE),
  allow_retry = T
)
```

```{r ggplot1, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot() + 
  facet_grid() + 
  geom_histogram()
```

```{r ggplot1-solution}
ggplot(data = socsupport, aes(x = emotionalsat)) + 
  facet_grid(livewith~.) + 
  geom_histogram()
```

```{r ggplot1-check, message = FALSE, warning = FALSE}
grade_code()
```

This plot could use a few adjustments. First, notice that we have six rows and that some of the histograms are kind of cramped. You may think it's easier to see the distributions with three rows of two histograms each (or some other combination). This can be done using `facet_wrap()` instead of `facet_grid()`.  

Instead of a formula, `facet_wrap` requires you to define the facets by selecting a variable with the `vars()` function (I've added this below so you can see an example). `facet_wrap` also requires you to set either the number of rows using `nrow` or the number of columns using `ncol`. See if you can use the code below to create a graph with three rows (or, if you prefer, two columns).

```{r ggplot2, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot() + 
  facet_wrap(vars(livewith)) + 
  geom_histogram()
```

```{r ggplot2-solution}
ggplot(data = socsupport, aes(x = emotionalsat)) + 
  facet_wrap(vars(livewith), nrow = 3) + 
  geom_histogram()
```

```{r ggplot2-check, message = FALSE, warning = FALSE}
grade_code()
```

You may have gotten a message telling you to pick a better value with `binwidth`. This can also be addressed by setting the number of bins with `bins`. Remember that a good rule of thumb is to use the square root of the total sample size.

```{r bins, echo = F}
question("If our dataset has 95 observations, what is a reasonable number of bins?",
  answer("95"),
  answer("10", correct = TRUE),
  answer("30"), 
  answer("6"),
  allow_retry = T
)
```

Use your answer from the previous question to change the number of bins (remember to keep the facets!).

```{r ggplot3, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot() + 
  facet_wrap() + 
  geom_histogram()
```

```{r ggplot3-solution}
ggplot(data = socsupport, aes(x = emotionalsat)) + 
  facet_wrap(vars(livewith), nrow = 3) + 
  geom_histogram(bins = 10)
```

```{r ggplot3-check, message = FALSE, warning = FALSE}
grade_code()
```

Remember that densities are less sensitive to arguments like `bins` or `binwidth`. It turns out that you can plot both at the same time if you want to compare the two types of plots--in fact, you can add any number of geoms! Just add `geom_density()` to your existing code. 

```{r ggplot4, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot() + 
  facet_wrap() + 
  geom_histogram() +
```

```{r ggplot4-solution}
ggplot(data = socsupport, aes(x = emotionalsat)) + 
  facet_wrap(vars(livewith), nrow = 3) + 
  geom_histogram(bins = 10) +
  geom_density()
```

```{r ggplot4-check, message = FALSE, warning = FALSE}
grade_code()
```

There may be just a tiny little black curve at the bottom of your plots. This is because densities are scaled from 0 to 1, but histograms in `ggplot2` are plotted with count data instead of frequency data (counts/sample size). To change this, add the argument `aes(y=..density..)` to `geom_histogram()`, like so: 

```{r ggplot5, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot(data = socsupport, aes(x = emotionalsat)) + 
  facet_wrap(vars(livewith), nrow = 3) + 
  geom_histogram(aes(y=..density..), bins = 10) +
  geom_density()
```

Now, everything should be on the same scale! 

We also talked in class about making boxplots. To get a boxplot for every level, the code is slightly different--there is no longer any need to use `facet_wrap` or `facet_grid`. Instead, you can specify an `x` and a `y` inside `aes()`--for horizontal boxplots, `y` should be your grouping variable, and for vertical boxplots, `x` should be your grouping variable. Create vertical boxplots for `emotionalsat` based off of `livewith` in the code chunk below. 

```{r ggplot6, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot(data = socsupport, aes(x = , y = )) + 

```

```{r ggplot6-solution}
ggplot(data = socsupport, aes(x = livewith, y = emotionalsat)) + 
  geom_boxplot() 
```

```{r ggplot6-check, message = FALSE, warning = FALSE}
grade_code()
```

We can further change the colors of the graph according to `livewith`. Add the argument `col = livewith` to your plot. What happens if instead of `col`, you specify `fill = livewith`?

```{r ggplot7, exercise = TRUE, exercise.setup = "prepare-part2"}
ggplot(data = socsupport, aes(x = livewith, y = emotionalsat, col = livewith)) + 
  geom_boxplot() 
```

```{r ggplot7-solution}
ggplot(data = socsupport, aes(x = livewith, y = emotionalsat, fill = livewith)) + 
  geom_boxplot() 
```

```{r ggplot7-check, message = FALSE, warning = FALSE}
grade_code()
```

Once you have checked the assumptions of normality and equal standard deviations with your plots, it may also help to look at the summary statistics for each group. The easiest way to do this is using `group_by()` and `summarize()` from `dplyr`--finally, you can begin to see why it is easier to use `dplyr` with `group_by()` to calculate summary statistics for many groups! Complete the lines of code below to get the mean, standard deviation, and counts of `emotionalsat` for each group from `livewith`. 

```{r dplyr1, exercise = TRUE, exercise.setup = "prepare-part2"}
socsupport %>% 
  group_by()
  summarize()
```

```{r dplyr1-solution}
socsupport %>% 
  group_by(livewith) %>%
  summarize(Mean = mean(emotionalsat), SD = sd(emotionalsat), n = n())
```

```{r dplyr1-check, message = FALSE, warning = FALSE}
grade_code()
```

Note that one of the groups, `parents`, has a missing observation (that's why the summary statistics show up as NA), and two of the groups, `alone` and `other`, have very small numbers associated with them. I'm going to remove the row with the missing observation and the two very small groups for the remainder of the analysis. 

#### ANOVA

```{r prepare-part3, message = FALSE}
socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv", stringsAsFactors = TRUE)
socsupport <- socsupport %>%
  filter(livewith %in% c("friends", "parents", "partner", "residences"), is.na(emotionalsat) != TRUE) 

mfull <- lm(data = socsupport, formula = emotionalsat ~ livewith)
```

Finally, we can carry out an ANOVA. First, define `mfull` using `lm()`. Don't forget you are estimating the means of `emotionalsat` based off of the group membership defined by `livewith`.


```{r formula2, echo = F}
question("Which is the correct formula for estimating the mean of `emotionalsat` from `livewith`?",
  answer("`emotionalsat~livewith`", correct = TRUE),
  answer("`livewith~emotionalsat`"),
  answer("`socsupport~emotionalsat`"),
  answer("`livewith~socsupport`"),
  allow_retry = T
)
```

```{r Ftest1, exercise = TRUE, exercise.setup = "prepare-part3"}
mfull <- lm(data = , formula = )
```

```{r Ftest1-solution}
mfull <- lm(data = socsupport, formula = emotionalsat ~ livewith)
```

```{r Ftest1-check, message = FALSE, warning = FALSE}
grade_code()
```

Now, using `anova()`, code an $F$-test to answer this question.

```{r Ftest2, exercise = TRUE, exercise.setup = "prepare-part3"}
anova()
```

```{r Ftest2-solution}
anova(mfull)
```

```{r Ftest2-check, message = FALSE, warning = FALSE}
grade_code()
```

Based on this test, what conclusions can you draw about emotional satisfaction?

## Part 4: `kable()`
 
As we work on creating RMarkdown documents, it is useful to know how to format tables directly in RMarkdown. We will learn how to create tables in R in both html documents (like the browser tab you are working in) and PDFs (like you usually do for homework). You will need the `kableExtra` package--install and load the package using the lines below. 

```{r prepare-kable}
library(kableExtra)

series <- c("Harry Potter", "Lord of the Rings", "Game of Thrones", "Chronicles of Narnia", "A Wrinkle in Time", "Hunger Games")
book.no <- c(7, 3, 5, 7, 5, 3)

table1 <- cbind(series, book.no)

author <- c("Rowling", "Tolkien", "Martin", "Lewis", "L'Engle", "Collins")

table2 <- cbind(series, book.no, author)

copies <- c(500, 150, 90, 100, 14 + 6 + 10 + 10 + 6, 65) 
series_model <- lm(copies ~ book.no)
```

```{r kable0, exercise = TRUE, message = FALSE, warning = FALSE}
# You only need to install the package once! If you already have, ignore the next line.
# install.packages(kableExtra)
library(kableExtra)
```

To create a nicely formatted table in R Markdown, the first step is to aggregate the data that belongs in the table. You can do this using the `cbind()` command. 

Run the following code to create `table1`. Remember that the `c()` command creates vectors--then, the `cbind()` command binds vectors together as columns. Then, using the `author` vector, write your own code to create `table2`, which contains all three variables.

```{r kable1, exercise = TRUE, exercise.setup = "prepare-kable"}
series <- c("Harry Potter", "Lord of the Rings", "Game of Thrones", "Chronicles of Narnia", "A Wrinkle in Time", "Hunger Games")
book.no <- c(7, 3, 5, 7, 5, 3)

table1 <- cbind(series, book.no)

author <- c("Rowling", "Tolkien", "Martin", "Lewis", "L'Engle", "Collins")
```

```{r kable1-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
table2 <- cbind(series, book.no, author)
```

```{r kable1-check, message = FALSE, warning = FALSE}
grade_code()
```

The next step is to apply the `kable()` command. The following line of code demonstrates applying `kable()`. You should have a "nicer" looking table (perhaps not perfect, but we will learn more tricks in a minute). Write a line of code using `kable()` on `table2`.

```{r kable2, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html")
```

Notice! There is an extra argument, `format = "html"`, inside `kable()`. This is because you are currently working inside a browser tab. IN YOUR HOMEWORK, YOU WILL NEED TO USE THE ARGUMENT `format = "latex"` BECAUSE YOU ARE WORKING WITH LaTeX. `format = "html"` will throw errors when your document knits.

You may want to change the alignment of the values in the table--for instance, numbers are traditionally right aligned, so we could right align the column `book.no`. 

The following line of code will realign the columns. Note that you need to supply a vector with an alignment character ("l" for left align, "c" for centered, or "r" for right align) for each column! Now write your own line of code that centers the `series` and `author` columns but right aligns the `book.no` column.

```{r kable3, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html", align = c("c", "r"))
```

```{r kable3-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
kable(table2, format = "html", align = c("c", "r", "c"))
```

```{r kable3-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="align-hint">
**Hint:** You need to specify the alignment for every column--there should be three letters for three columns!
</div>

You may also want to rename the columns. The following line of code renames the columns for `table1`. Again, note that you need to supply a vector with a name, in quotation marks, for every column. Write your own line of code renaming the columns in `table2`. 

```{r kable4, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html", align = c("c", "r"), col.names = c("Fantasy Series", "Number of Books"))
```

```{r kable4-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
kable(table2, format = "html", align = c("c", "r", "c"), col.names = c("Fantasy Series", "Number of Books", "Author Last Name"))
```

```{r kable4-check, message = FALSE, warning = FALSE}
grade_code()
```

<div id="names-hint">
**Hint:** You need to specify a name for every column--there should be three names!
</div>

You can also put some finishing touches on your table--for instance, adding stripes to the rows (shown in the first two lines). 

```{r kable5, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html", align = c("c", "r"), col.names = c("Fantasy Series", "Number of Books")) %>%
  kable_styling(bootstrap_options = c("striped"))
kable(table2, format = "html", align = c("c", "r"), col.names = c("Fantasy Series", "Number of Books", "Author Last Name")) %>%
  kable_styling(bootstrap_options = c("bordered"))
```

```{r 10_5}
question("Try running the following lines of code. What do the last lines of the code do for your table?",
  answer("Adds borders", correct = TRUE, message = "You can also add all of the other options using the striped, condensed, and hover options."),
  answer("Adds a highlight when you hover over the line"),
  answer("Shades alternate rows of the table."),
  answer("Condenses the table cell heights"),
  allow_retry = T,
  random_answer_order = TRUE
)
```

There are more options than `"striped"` and `"bordered"`--unfortunately, they will only work with `format = "html"`. Do NOT try and use these in your homework!

You can also add captions to your tables, directly in R, using the `caption` argument! An example is shown in the following lines of code. Try adding a caption to your `table2`, labeling it as "Table 2". 

```{r kable6, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html", caption = "Table 1")
```

```{r kable6-solution, message = FALSE, warning = FALSE, echo = FALSE}
kable(table2, format = "html", caption = "Table 2")
```

```{r kable6-check, message = FALSE, warning = FALSE}
grade_code()
```

You may wish to change the alignment of the table the entire table. To do this, you need load the package `dplyr` and add an extra line of code, `kable_styling`, with the pipe operator. Change the lines of code that centers the summary of our model to lines of code that left aligns the table. 

```{r kable7, exercise = TRUE, message = FALSE, exercise.setup = "prepare-kable"}
kable(table2, format = "html", caption = "Table 2") %>% 
  kable_styling(position = "center")
```

```{r kable7-solution, message = FALSE, warning = FALSE, echo = FALSE, exercise.setup = "prepare-kable"}
kable(table2, format = "html", caption = "Table 2") %>% 
  kable_styling(position = "left")
```

```{r kable7-check, message = FALSE, warning = FALSE}
grade_code()
```

You might also want to change the font size. You can do this using the following line of code. Write a line of code to change the font size of your `table2`.

```{r kable8, exercise = TRUE, exercise.setup = "prepare-kable"}
kable(table1, format = "html", caption = "Table 1") %>% 
  kable_styling(position = "center", font_size = 22)
```

```{r kable8-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
kable(table2, align = c("c", "r"), caption = "Table 2") %>%
  kable_styling(position = "center", font_size = 22)
```

```{r kable8-check, message = FALSE, warning = FALSE}
grade_code()
```

Since we will be working with a lot of summary statistics for different groups, you may be interested in creating tables for `dplyr` output. Run the following lines of code. 

```{r kable9, exercise = TRUE, exercise.setup = "prepare-part3"}
sumstats_socsupport <- socsupport %>% 
  group_by(livewith) %>%
  summarize(Mean = mean(emotionalsat), SD = sd(emotionalsat), n = n())

kable(sumstats_socsupport, format = "html")
```

Not terrible, but not great either. The first thing that I notice is that the number of digits makes it hard to read. To fix this, we can add a `format()` command. `format()` accepts two arguments--the object you want formatted and the number of digits you want in the output.

```{r prepare-part4, message = FALSE}
socsupport <- read.csv("https://vincentarelbundock.github.io/Rdatasets/csv/DAAG/socsupport.csv", stringsAsFactors = TRUE)
socsupport <- socsupport %>%
  filter(livewith %in% c("friends", "parents", "partner", "residences"), is.na(emotionalsat) != TRUE) 

sumstats_socsupport <- socsupport %>% 
  group_by(livewith) %>%
  summarize(Mean = mean(emotionalsat), SD = sd(emotionalsat), n = n())

mfull <- lm(data = socsupport, formula = emotionalsat ~ livewith)
```

```{r kable10, exercise = TRUE, exercise.setup = "prepare-part4"}
kable(format(sumstats_socsupport, digits = 3), format = "html")
```

This is slightly easier to read, but still not great. Fix the column alignment so all three columns are right-aligned.

```{r kable11, exercise = TRUE, exercise.setup = "prepare-part4"}
kable(format(sumstats_socsupport, digits = 3), format = "html")
```

```{r kable11-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
kable(format(sumstats_socsupport, digits = 3), align = c("r", "r", "r"), format = "html")
```

```{r kable11-check, message = FALSE, warning = FALSE}
grade_code()
```

Getting there! You may have noticed a few extra lines at the beginning of your table. `dplyr` outputs tables in the form `tibble`, which doesn't play nice with `kable()`. To fix this, you usually need to change the storage form--a data frame will do just fine.

```{r kable12, exercise = TRUE, exercise.setup = "prepare-part4"}
sumstats_socsupport <- as.data.frame(sumstats_socsupport)

kable(format(sumstats_socsupport, digits = 3), align = c("r", "r", "r"), format = "html")
```

This is very cramped--there are different ways to fix this issue, but for now, you can change the `bootstrap_options` inside the `kable_styling()` function. On your homework, fixing `format = "latex"` will address the problem. 

```{r kable13, exercise = TRUE, exercise.setup = "prepare-part4"}
sumstats_socsupport <- as.data.frame(sumstats_socsupport)

kable(format(sumstats_socsupport, digits = 3), align = c("r", "r", "r"), format = "html") %>%
  kable_styling(bootstrap_options = c("bordered"))
```

The other thing you might want to do is format the ANOVA table nicely. Instead of `sumstats_socsupport`, input `anova(mfull)`. 

```{r kable14, exercise = TRUE, exercise.setup = "prepare-part4"}
kable(format(sumstats_socsupport, digits = 3), format = "html")
```

```{r kable14-solution, message = FALSE, warning = FALSE, echo = FALSE, echo = FALSE}
kable(format(anova(mfull), digits = 3), format = "html")
```

```{r kable14-check, message = FALSE, warning = FALSE}
grade_code()
```

We'll learn more about how to clean this up later--but now you should be able to create nicely formatted tables directly in R. Remember on your homework to use `format = "latex"` instead of `format = "html"`!!


